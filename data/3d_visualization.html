<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>World Model 3D Viewer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
            background-color: #000;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #viewer {
            width: 100%;
            height: 100%;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            max-width: 300px;
            font-size: 12px;
        }

        #info {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            max-width: 250px;
            font-size: 12px;
        }

        .control-group {
            margin-bottom: 10px;
        }

        .control-group label {
            display: block;
            margin-bottom: 3px;
            font-weight: bold;
        }

        button {
            background-color: #4287f5;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            margin-right: 5px;
        }

        button:hover {
            background-color: #3170c4;
        }

        input[type="checkbox"] {
            margin-right: 5px;
        }

        input[type="range"] {
            width: 100%;
        }

        .stats {
            font-family: monospace;
            font-size: 11px;
        }

        .legend {
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 3px;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 5px;
            border: 1px solid #333;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="viewer"></div>
        <div id="loading">Loading 3D Viewer...</div>

        <div id="controls">
            <h3>World Model Controls</h3>

            <div class="control-group">
                <label>Display Options</label>
                <input type="checkbox" id="showPointCloud" checked> Point Cloud<br>
                <input type="checkbox" id="showBoundingBoxes" checked> Bounding Boxes<br>
                <input type="checkbox" id="showTrajectories" checked> Trajectories<br>
                <input type="checkbox" id="showSensors" checked> Sensors<br>
                <input type="checkbox" id="showMap" checked> Map Elements
            </div>

            <div class="control-group">
                <label>Point Size</label>
                <input type="range" id="pointSize" min="0.01" max="1.0" step="0.01" value="0.1">
            </div>

            <div class="control-group">
                <label>Camera</label>
                <button onclick="resetCamera()">Reset View</button>
                <button onclick="topView()">Top View</button>
                <button onclick="sideView()">Side View</button>
            </div>

            <div class="control-group">
                <label>Animation</label>
                <button onclick="toggleAnimation()">Play/Pause</button>
                <button onclick="stepForward()">Step Forward</button>
            </div>

            <div class="legend">
                <label>Legend</label>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #4287f5;"></div>
                    <span>Vehicle</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #f54242;"></div>
                    <span>Pedestrian</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #f5a442;"></div>
                    <span>Cyclist</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #888888;"></div>
                    <span>Building</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #00ff00;"></div>
                    <span>Sensor</span>
                </div>
            </div>
        </div>

        <div id="info">
            <h3>Scene Information</h3>
            <div class="stats">
                <div>Objects: <span id="objectCount">0</span></div>
                <div>Points: <span id="pointCount">0</span></div>
                <div>FPS: <span id="fps">60</span></div>
                <div>Time: <span id="currentTime">0.00</span>s</div>
            </div>

            <h4>Selected Object</h4>
            <div id="selectedInfo" class="stats">
                None
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/PLYLoader.js"></script>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let animationMixer = null;
        let isAnimating = false;
        let currentTime = 0;
        let frameCount = 0;
        let lastFrameTime = performance.now();

        // Visualization objects
        let visualizationObjects = new Map();
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let selectedObject = null;

        // Configuration
        const config = {
            pointSize: 0.1,
            showPointCloud: true,
            showBoundingBoxes: true,
            showTrajectories: true,
            showSensors: true,
            showMap: true
        };

        // Initialize Three.js scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.Fog(0x000000, 50, 500);

            // Create camera
            camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            camera.position.set(50, 50, 50);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            const viewer = document.getElementById('viewer');
            viewer.appendChild(renderer.domElement);

            // Create controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Add lights
            setupLighting();

            // Add grid
            addGrid();

            // Add event listeners
            setupEventListeners();

            // Hide loading
            document.getElementById('loading').style.display = 'none';

            // Start animation loop
            animate();
        }

        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            // Directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Point lights
            const pointLight1 = new THREE.PointLight(0xffffff, 0.5, 100);
            pointLight1.position.set(25, 25, 25);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xffffff, 0.5, 100);
            pointLight2.position.set(-25, 25, -25);
            scene.add(pointLight2);
        }

        function addGrid() {
            const gridHelper = new THREE.GridHelper(200, 50, 0x444444, 0x222222);
            scene.add(gridHelper);

            // Add axes helper
            const axesHelper = new THREE.AxesHelper(50);
            scene.add(axesHelper);
        }

        function setupEventListeners() {
            // Window resize
            window.addEventListener('resize', onWindowResize, false);

            // Mouse events for object selection
            renderer.domElement.addEventListener('click', onMouseClick, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);

            // Control events
            document.getElementById('pointSize').addEventListener('input', (e) => {
                config.pointSize = parseFloat(e.target.value);
                updatePointCloudSizes();
            });

            document.getElementById('showPointCloud').addEventListener('change', (e) => {
                config.showPointCloud = e.target.checked;
                updateObjectVisibility();
            });

            document.getElementById('showBoundingBoxes').addEventListener('change', (e) => {
                config.showBoundingBoxes = e.target.checked;
                updateObjectVisibility();
            });

            document.getElementById('showTrajectories').addEventListener('change', (e) => {
                config.showTrajectories = e.target.checked;
                updateObjectVisibility();
            });

            document.getElementById('showSensors').addEventListener('change', (e) => {
                config.showSensors = e.target.checked;
                updateObjectVisibility();
            });

            document.getElementById('showMap').addEventListener('change', (e) => {
                config.showMap = e.target.checked;
                updateObjectVisibility();
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                const intersectedObject = intersects[0].object;
                selectObject(intersectedObject);
            } else {
                deselectObject();
            }
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            document.body.style.cursor = intersects.length > 0 ? 'pointer' : 'default';
        }

        function selectObject(object) {
            // Deselect previous object
            if (selectedObject) {
                selectedObject.material.emissive = new THREE.Color(0x000000);
            }

            selectedObject = object;

            // Highlight selected object
            if (selectedObject && selectedObject.material) {
                selectedObject.material.emissive = new THREE.Color(0x444444);
            }

            // Update info panel
            updateSelectedInfo();
        }

        function deselectObject() {
            if (selectedObject && selectedObject.material) {
                selectedObject.material.emissive = new THREE.Color(0x000000);
            }
            selectedObject = null;
            updateSelectedInfo();
        }

        function updateSelectedInfo() {
            const infoDiv = document.getElementById('selectedInfo');

            if (selectedObject && selectedObject.userData) {
                const data = selectedObject.userData;
                let html = `
                    <div>ID: ${data.id || 'N/A'}</div>
                    <div>Type: ${data.type || 'N/A'}</div>
                    <div>Category: ${data.category || 'N/A'}</div>
                `;

                if (data.confidence !== undefined) {
                    html += `<div>Confidence: ${data.confidence.toFixed(2)}</div>`;
                }

                infoDiv.innerHTML = html;
            } else {
                infoDiv.innerHTML = 'None';
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            // Update FPS
            frameCount++;
            const currentTimeFrame = performance.now();
            if (currentTimeFrame - lastFrameTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastFrameTime = currentTimeFrame;
            }

            // Update animation
            if (isAnimating && animationMixer) {
                animationMixer.update(0.016); // 60 FPS
                currentTime += 0.016;
                document.getElementById('currentTime').textContent = currentTime.toFixed(2);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        function resetCamera() {
            camera.position.set(50, 50, 50);
            camera.lookAt(0, 0, 0);
            controls.reset();
        }

        function topView() {
            camera.position.set(0, 100, 0);
            camera.lookAt(0, 0, 0);
            controls.update();
        }

        function sideView() {
            camera.position.set(100, 20, 0);
            camera.lookAt(0, 0, 0);
            controls.update();
        }

        function toggleAnimation() {
            isAnimating = !isAnimating;
        }

        function stepForward() {
            if (animationMixer) {
                animationMixer.update(0.1);
                currentTime += 0.1;
                document.getElementById('currentTime').textContent = currentTime.toFixed(2);
            }
        }

        function updatePointCloudSizes() {
            scene.traverse((child) => {
                if (child.isPoints && child.material) {
                    child.material.size = config.pointSize;
                    child.material.needsUpdate = true;
                }
            });
        }

        function updateObjectVisibility() {
            scene.traverse((child) => {
                if (child.userData) {
                    const type = child.userData.type;
                    let visible = true;

                    switch (type) {
                        case 'point_cloud':
                            visible = config.showPointCloud;
                            break;
                        case 'bounding_box':
                            visible = config.showBoundingBoxes;
                            break;
                        case 'trajectory':
                            visible = config.showTrajectories;
                            break;
                        case 'sensor':
                            visible = config.showSensors;
                            break;
                        case 'map_element':
                            visible = config.showMap;
                            break;
                    }

                    child.visible = visible;
                }
            });
        }

        function updateStatistics() {
            let objectCount = 0;
            let pointCount = 0;

            scene.traverse((child) => {
                if (child.userData) {
                    objectCount++;
                    if (child.isPoints) {
                        pointCount += child.geometry.attributes.position.count;
                    }
                }
            });

            document.getElementById('objectCount').textContent = objectCount;
            document.getElementById('pointCount').textContent = pointCount;
        }

        // World Model data loading functions
        function loadWorldModelData(worldModelData) {
            clearScene();

            if (worldModelData.point_clouds) {
                worldModelData.point_clouds.forEach(data => addPointCloud(data));
            }

            if (worldModelData.objects) {
                worldModelData.objects.forEach(data => addBoundingBox(data));
            }

            if (worldModelData.trajectories) {
                worldModelData.trajectories.forEach(data => addTrajectory(data));
            }

            if (worldModelData.sensors) {
                worldModelData.sensors.forEach(data => addSensor(data));
            }

            if (worldModelData.map_elements) {
                worldModelData.map_elements.forEach(data => addMapElement(data));
            }

            updateStatistics();
        }

        function clearScene() {
            const objectsToRemove = [];

            scene.traverse((child) => {
                if (child.userData) {
                    objectsToRemove.push(child);
                }
            });

            objectsToRemove.forEach((child) => {
                scene.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });

            visualizationObjects.clear();
        }

        // Load world model data from the server
        async function loadWorldModelFromServer(scenarioId, timestamp = null) {
            try {
                let url = `/api/world_model/${scenarioId}`;
                if (timestamp) {
                    url += `?timestamp=${timestamp}`;
                }

                const response = await fetch(url);
                const data = await response.json();
                loadWorldModelData(data);
            } catch (error) {
                console.error('Error loading world model data:', error);
            }
        }

        // Initialize when page loads
        window.addEventListener('load', init);

        // Load sample data on initialization
        window.addEventListener('load', () => {
            // This will be replaced with actual data loading
            setTimeout(() => {
                loadWorldModelFromServer('default_scenario');
            }, 1000);
        });
    </script>

    <!-- World Model Data Loading Script -->
    <script>
        // This script will be injected with the actual world model data
        const worldModelData = {"point_clouds": [{"id": "sample_pc", "position": [0, 0, 0], "points": [[-10, 0, -10], [-10, 0, -8], [-10, 0, -6], [-10, 0, -4], [-10, 0, -2], [-10, 0, 0], [-10, 0, 2], [-10, 0, 4], [-10, 0, 6], [-10, 0, 8], [-10, 0, 10], [-8, 0, -10], [-8, 0, -8], [-8, 0, -6], [-8, 0, -4], [-8, 0, -2], [-8, 0, 0], [-8, 0, 2], [-8, 0, 4], [-8, 0, 6], [-8, 0, 8], [-8, 0, 10], [-6, 0, -10], [-6, 0, -8], [-6, 0, -6], [-6, 0, -4], [-6, 0, -2], [-6, 0, 0], [-6, 0, 2], [-6, 0, 4], [-6, 0, 6], [-6, 0, 8], [-6, 0, 10], [-4, 0, -10], [-4, 0, -8], [-4, 0, -6], [-4, 0, -4], [-4, 0, -2], [-4, 0, 0], [-4, 0, 2], [-4, 0, 4], [-4, 0, 6], [-4, 0, 8], [-4, 0, 10], [-2, 0, -10], [-2, 0, -8], [-2, 0, -6], [-2, 0, -4], [-2, 0, -2], [-2, 0, 0], [-2, 0, 2], [-2, 0, 4], [-2, 0, 6], [-2, 0, 8], [-2, 0, 10], [0, 0, -10], [0, 0, -8], [0, 0, -6], [0, 0, -4], [0, 0, -2], [0, 0, 0], [0, 0, 2], [0, 0, 4], [0, 0, 6], [0, 0, 8], [0, 0, 10], [2, 0, -10], [2, 0, -8], [2, 0, -6], [2, 0, -4], [2, 0, -2], [2, 0, 0], [2, 0, 2], [2, 0, 4], [2, 0, 6], [2, 0, 8], [2, 0, 10], [4, 0, -10], [4, 0, -8], [4, 0, -6], [4, 0, -4], [4, 0, -2], [4, 0, 0], [4, 0, 2], [4, 0, 4], [4, 0, 6], [4, 0, 8], [4, 0, 10], [6, 0, -10], [6, 0, -8], [6, 0, -6], [6, 0, -4], [6, 0, -2], [6, 0, 0], [6, 0, 2], [6, 0, 4], [6, 0, 6], [6, 0, 8], [6, 0, 10], [8, 0, -10], [8, 0, -8], [8, 0, -6], [8, 0, -4], [8, 0, -2], [8, 0, 0], [8, 0, 2], [8, 0, 4], [8, 0, 6], [8, 0, 8], [8, 0, 10], [10, 0, -10], [10, 0, -8], [10, 0, -6], [10, 0, -4], [10, 0, -2], [10, 0, 0], [10, 0, 2], [10, 0, 4], [10, 0, 6], [10, 0, 8], [10, 0, 10]], "point_size": 0.2, "point_color": "#00ff00", "color": "#00ff00", "opacity": 0.8}], "objects": [{"id": "vehicle_1", "position": [5, 1, 5], "size": [4, 1.5, 2], "rotation": [0, 45, 0], "category": "vehicle", "color": "#4287f5", "opacity": 0.7, "confidence": 0.95, "wireframe": false}, {"id": "pedestrian_1", "position": [-3, 1, -2], "size": [0.5, 1.8, 0.5], "rotation": [0, 0, 0], "category": "pedestrian", "color": "#f54242", "opacity": 0.7, "confidence": 0.88, "wireframe": false}, {"id": "road_1", "position": [0, 0, 0], "size": [20, 0.1, 40], "rotation": [0, 0, 0], "category": "road", "color": "#666666", "opacity": 0.8, "confidence": 1.0, "wireframe": true}, {"id": "building_1", "position": [15, 5, 15], "size": [10, 10, 10], "rotation": [0, 0, 0], "category": "building", "color": "#888888", "opacity": 0.8, "confidence": 1.0, "wireframe": false}], "trajectories": [{"id": "vehicle_trajectory", "waypoints": [[-5, 0, -5], [0, 0, 0], [5, 0, 5], [10, 0, 10]], "line_color": "#ff0000", "line_width": 3.0, "closed_loop": false}], "sensors": [{"id": "lidar_sensor", "position": [0, 2, 0], "rotation": [0, 0, 0], "fov": 360, "range": 100, "aspect_ratio": 1.0, "color": "#00ff00", "opacity": 0.3, "type": "lidar"}, {"id": "camera_sensor", "position": [0, 2, 0], "rotation": [0, 0, 0], "fov": 60, "range": 50, "aspect_ratio": 1.777, "color": "#00ff00", "opacity": 0.3, "type": "camera"}], "map_elements": []};

        if (worldModelData) {
            window.addEventListener('load', () => {
                loadWorldModelData(worldModelData);
            });
        }
    </script>
</body>
</html>